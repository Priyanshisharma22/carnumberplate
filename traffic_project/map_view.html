<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Traffic Phase Distance Map</title>
<style>
  body {
    margin: 0;
    background: #0e1116;
    color: #f3f3f3;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  #canvas {
    width: 100vw;
    height: 100vh;
    display: block;
    cursor: grab;
  }
  #toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    background: #1a1f29;
    border: 1px solid #2a3244;
    border-radius: 10px;
    padding: 8px;
  }
  #toolbar button {
    margin: 2px;
    padding: 6px 10px;
    background: #243043;
    color: #fff;
    border: 1px solid #2a3244;
    border-radius: 6px;
    cursor: pointer;
  }
  #toolbar button:hover {
    background: #32415a;
  }
  #toolbar input {
    width: 60px;
    text-align: center;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="toolbar">
  <button id="zoomIn">Ôºã</button>
  <button id="zoomOut">Ôºç</button>
  <button id="reset">Reset</button>
  <button id="randomize">üé≤ Randomize</button>
  <label><input type="checkbox" id="lockP12" checked /> Lock P1‚ÄìP2=4 km</label>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// Match Python layout (1920√ó1080 world)
const WIDTH = 1920, HEIGHT = 1080;
const X1 = WIDTH / 3, X2 = (WIDTH * 2) / 3;
const Y1 = HEIGHT / 3, Y2 = (HEIGHT * 2) / 3;
const INTER_SIZE = 120, INTER_HALF = INTER_SIZE / 2;
const PHASES = [
  { label: "Phase 1", x: X1, y: Y1 },
  { label: "Phase 2", x: X2, y: Y1 },
  { label: "Phase 3", x: X1, y: Y2 },
  { label: "Phase 4", x: X2, y: Y2 },
];
const CONNECTIONS = [
  { a: 0, b: 1, key: "P1‚ÄìP2" },
  { a: 2, b: 3, key: "P3‚ÄìP4" },
  { a: 0, b: 2, key: "P1‚ÄìP3" },
  { a: 1, b: 3, key: "P2‚ÄìP4" },
];

let distances = {
  "P1‚ÄìP2": 4.0,
  "P3‚ÄìP4": 6.0,
  "P1‚ÄìP3": 5.5,
  "P2‚ÄìP4": 7.0,
};

// Zoom/Pan
let scale = 0.5;
let offsetX = 0;
let offsetY = 0;
let dragging = false;
let lastX, lastY;

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  draw();
}
window.addEventListener("resize", resize);
resize();

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
  canvas.style.cursor = "grabbing";
});
window.addEventListener("mouseup", () => {
  dragging = false;
  canvas.style.cursor = "grab";
});
window.addEventListener("mousemove", e => {
  if (!dragging) return;
  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  draw();
});
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  scale = Math.min(3, Math.max(0.2, scale * zoomFactor));
  draw();
});

document.getElementById("zoomIn").onclick = () => { scale = Math.min(scale * 1.2, 3); draw(); };
document.getElementById("zoomOut").onclick = () => { scale = Math.max(scale / 1.2, 0.2); draw(); };
document.getElementById("reset").onclick = () => { scale = 0.5; offsetX = 0; offsetY = 0; draw(); };
document.getElementById("randomize").onclick = () => randomizeDistances();

function randomizeDistances() {
  CONNECTIONS.forEach(c => {
    if (c.key === "P1‚ÄìP2" && document.getElementById("lockP12").checked) {
      distances[c.key] = 4.0;
    } else {
      distances[c.key] = +(Math.random() * 9 + 1).toFixed(1);
    }
  });
  draw();
}

function worldToScreen(x, y) {
  return [
    (x - WIDTH / 2) * scale + canvas.width / 2 + offsetX,
    (y - HEIGHT / 2) * scale + canvas.height / 2 + offsetY
  ];
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#0d1118";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // draw roads
  ctx.save();
  ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
  ctx.scale(scale, scale);
  ctx.translate(-WIDTH / 2, -HEIGHT / 2);
  ctx.fillStyle = "#111";
  const ROAD = 60;
  ctx.fillRect(0, Y1 - ROAD / 2, WIDTH, ROAD);
  ctx.fillRect(0, Y2 - ROAD / 2, WIDTH, ROAD);
  ctx.fillRect(X1 - ROAD / 2, 0, ROAD, HEIGHT);
  ctx.fillRect(X2 - ROAD / 2, 0, ROAD, HEIGHT);

  // intersections
  PHASES.forEach((p, i) => {
    ctx.fillStyle = "#c33";
    ctx.fillRect(p.x - INTER_HALF, p.y - INTER_HALF, INTER_SIZE, INTER_SIZE);

    // label
    ctx.fillStyle = "yellow";
    ctx.font = "24px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(p.label, p.x, p.y);
  });

  // distances
  CONNECTIONS.forEach(c => {
    const A = PHASES[c.a], B = PHASES[c.b];
    ctx.strokeStyle = "#1e90ff";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.stroke();

    // distance label
    const mx = (A.x + B.x) / 2;
    const my = (A.y + B.y) / 2;
    ctx.fillStyle = "#80c0ff";
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText(`${distances[c.key]} km`, mx, my - 10);
  });

  ctx.restore();
}
draw();
</script>
</body>
</html>
